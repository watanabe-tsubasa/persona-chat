import { streamText } from "ai";
import type { NextRequest } from "next/server";
import { openai } from "@/lib/ai";
import { supabaseServer } from "@/lib/supabase-server";

export const runtime = "edge";

export async function POST(req: NextRequest) {
  try {
    type ChatPart =
      | { type: "text"; text: string }
      | { type: string; text?: string };
    type ChatMessage = {
      role: "user" | "assistant" | "system";
      parts?: ChatPart[];
    };

    const body = (await req.json()) as {
      personaId?: string;
      messages: ChatMessage[];
    };

    // üîç „Éá„Éê„ÉÉ„Ç∞„É≠„Ç∞
    console.log("=== /api/chat request body ===");
    console.dir(body, { depth: null });
    console.log("==============================");

    const { personaId, messages } = body;

    if (!Array.isArray(messages)) {
      console.error("‚ùå messages „ÅåÈÖçÂàó„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì", messages);
      return new Response(JSON.stringify({ error: "messages is required" }), {
        status: 400,
      });
    }

    // personaId „ÅåÁÑ°„Åë„Çå„Å∞„Éá„Éï„Ç©„É´„Éà‰∫∫Ê†º„Çí‰Ωø„ÅÜ
    let system = "„ÅÇ„Å™„Åü„ÅØË¶™Âàá„Å™„Ç¢„Ç∑„Çπ„Çø„É≥„Éà„Åß„Åô„ÄÇ";
    const fixedPairs: { role: "user" | "assistant"; content: string }[] = [];

    if (personaId) {
      const supabase = supabaseServer();
      const { data: persona, error } = await supabase
        .from("personas")
        .select("persona_prompt, examples")
        .eq("id", personaId)
        .single();

      if (!error && persona) {
        system = persona.persona_prompt;
        if (persona.examples) {
          const blocks = (persona.examples as string).split(/\n\n+/);
          for (const b of blocks) {
            const m = b.match(/user:\s*([\s\S]*?)\nassistant:\s*([\s\S]*)$/);
            if (m) {
              fixedPairs.push({ role: "user", content: m[1] });
              fixedPairs.push({ role: "assistant", content: m[2] });
            }
          }
        }
      } else {
        console.error(
          "‚ö†Ô∏è personaId „ÅØ„ÅÇ„Çã„Åå Supabase „Åã„ÇâÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì",
          error,
        );
      }
    }

    // parts „Çí string „Å´Â§âÊèõ
    const clipped = messages.slice(-6).map((m) => {
      const textParts =
        m.parts?.map((p) => (p.type === "text" ? p.text : "")).join("") ?? "";
      return { role: m.role, content: textParts };
    });

    console.log("=== /api/chat merged messages ===");
    console.dir([...fixedPairs, ...clipped], { depth: null });
    console.log("=================================");

    const result = streamText({
      model: openai("gpt-5-chat-latest"),
      system,
      messages: [...fixedPairs, ...clipped],
    });

    // useChat Áî®„É¨„Çπ„Éù„É≥„Çπ
    return result.toUIMessageStreamResponse();
  } catch (e: unknown) {
    console.error("‚ùå /api/chat failed", e);
    return new Response(JSON.stringify({ error: "chat failed" }), {
      status: 500,
    });
  }
}
